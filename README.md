# 전체 시스템 설계

### 텍스트 콘솔 RPG 컨셉 : **C++ 모험 RPG**

![컨셉아트](https://raw.githubusercontent.com/JongKyuHong/image/main/컨셉아트.png)

## 🌐 Code World : 게임 컨셉

### **코드월드 (Code World)**

- 변수 · 조건문 · 구조 설계 등 **프로그래밍 요소로 구성된 세계**
- 몬스터: **C++ 개념의 캐릭터화**
- 개념들이 실체화되며 질서가 불안정한 상태

---

### **플레이어 역할**

- 코드월드의 문제를 해결하는 플레이어
- 라운드를 진행하며 **C++ 개념 몬스터를 정복**
- 전투를 통해 이해와 숙련을 축적

---

### **게임 진행 구조**

- 라운드 단위 진행
- 몬스터 처치 → **개념 격파 및 캐릭터 성장**
- 라운드 종료 시 핵심 개념을 집약한 보스 등장
- 보스 클리어 후 다음 단계로 진행

---

<details>
  <summary>스토리</summary>

# C++ 모험 RPG

## 스토리

---

**배경**

코드월드에는 수많은 몬스터들이 존재한다. 이들은 프로그래밍의 지식을 흩트려 놓고, 혼돈을 만든다. 용감한 플레이어인 너는 **“코드 마스터”**가 되어 몬스터들을 물리치고, 각 라운드의 보스를 쓰러트려야 한다.

---

### **라운드 1: 변수의 숲**

- **몬스터 등장:** 변수, 상수, 자료형, 초기화, 선언
- **목표:** 모든 몬스터를 물리치고 **레벨 3** 달성
- **보스:** 포인터
- **스토리:**
  숲 속에서 너를 기다리는 몬스터들은 기초적인 코드 지식을 시험한다. 포인터 보스는 변수의 주소를 자유자재로 조종하며 공격해온다. 이를 이겨야 다음 단계로 나아갈 수 있다.

---

### **라운드 2: 클래스의 성**

- **몬스터 등장:** 클래스, 객체, 멤버변수, 함수, 생성자/소멸자
- **목표:** 모든 몬스터를 물리치고 **레벨 6** 달성
- **보스:** 다형성 혹은 상속 보스
- **스토리:**
  고대의 성 안에서 클래스 몬스터들이 너를 시험한다. 보스는 다양한 형태로 변신하며 다형성의 힘을 보여준다. 이 보스를 넘어야 진정한 객체 지향의 힘을 깨닫게 된다.

---

### **라운드 3: 디자인 패턴의 탑**

- **몬스터 등장:** 싱글톤, 데코레이터, 옵저버, 전략 패턴 등
- **목표:** 모든 몬스터를 물리치고 **레벨 10** 달성
- **보스:** 팀 프로젝트
- **스토리:**
  탑 꼭대기에서 너를 기다리는 것은 혼자서는 상대할 수 없는 거대한 보스, 팀 프로젝트! 디자인 패턴 몬스터들을 모두 물리치고, 협업과 패턴을 활용해야만 승리할 수 있다.

---

⚔️ **최종 목표:**

모든 라운드를 클리어하고 코드월드를 정복하여 **최고의 코드 마스터**가 되라!

## FlowChart

## 출현 몬스터 정리

### 1라운드: 기본 문법 (Basic Syntax)

| 구분 | 개념   | 클래스 명     | 설명                                 |
| ---- | ------ | ------------- | ------------------------------------ |
| 일반 | 변수   | VariableSlime | 값이 변하는 물렁물렁한 슬라임        |
| 일반 | 상수   | ConstantGolem | 변하지 않는 단단한 바위 골렘         |
| 일반 | 자료형 | TypeSpirit    | 데이터의 형태를 결정하는 정령        |
| 일반 | 초기화 | InitWisp      | 시작할 때 빛을 내는 위스프           |
| 일반 | 선언   | DeclareShadow | 실체 없이 이름만 먼저 보이는 그림자  |
| 보스 | 포인터 | PointerLich   | 주소를 가리키며 조종하는 강력한 리치 |

### 2라운드: 객체 지향 (OOP)

| 구분 | 개념     | 클래스 명         | 설명                                 |
| ---- | -------- | ----------------- | ------------------------------------ |
| 일반 | 클래스   | ClassMimic        | 무엇이든 찍어낼 수 있는 상자 괴물    |
| 일반 | 객체     | ObjectOrc         | 클래스에서 실체화된 강력한 오크      |
| 일반 | 멤버변수 | MemberSpider      | 객체 내부의 데이터를 지키는 거미     |
| 일반 | 함수     | FunctionMage      | 기능을 수행하고 값을 반환하는 마법사 |
| 일반 | 생성자   | ConstructGargoyle | 객체가 생성될 때 깨어나는 가고일     |
| 일반 | 소멸자   | DestructReaper    | 객체가 사라질 때 나타나는 사신       |
| 보스 | 다형성   | PolyDragon        | 여러 형태(타입)로 변신하는 드래곤    |

### 3라운드: 디자인 패턴 & 최종 (Design Pattern & Final)

| 구분 | 개념        | 클래스 명        | 설명                                  |
| ---- | ----------- | ---------------- | ------------------------------------- |
| 일반 | 싱글톤      | SingletonKing    | 오직 하나만 존재하는 왕               |
| 일반 | 데코레이터  | DecoratorKnight  | 장비를 덧붙여 강해지는 기사           |
| 일반 | 옵저버      | ObserverBeholder | 상태 변화를 감시하는 눈 괴물(비홀더)  |
| 일반 | 전략        | StrategyGeneral  | 상황에 따라 전술을 바꾸는 장군        |
| 보스 | 팀 프로젝트 | TeamProjectDevil | 모든 것을 통합하고 시험하는 최종 마왕 |

## </details>

---

### 최종 목표

- 모든 라운드를 클리어
- 코드월드의 질서를 회복
- **C++ 마스터 달성**

---

## 🧩 설계 단계 아이디어 정리

### 🎨 표현 · 연출 방향

- ASCII 아트 기반 텍스트 화면 구성
- 인트로 · 로고 연출 아이디어
- 효과음을 통한 몰입감 강화 구상

---

### 👾 세계관 · 캐릭터 설계

- C++ 개념을 몬스터로 캐릭터화
- 튜터님 몬스터 혹은 관련 아이템 등장 구상

---

### ⚔ 플레이 흐름 구상

- 라운드 단위 전투 구조 설계
- 전투 중 플레이어 스탯 상시 노출
- 전투와 아이템 사용 시점 분리 아이디어
  - 전투 전 / 전투 중 / 전투 후

---

### 📈 성장 시스템 구상

- 스킬 시스템 구상
- 전직 시스템 방향성
- 강화 시스템 아이디어

- 장비 아이템 개념 도입
- 전리품 기반 성장 흐름

### 모듈화된 시스템 구현

다형성 / 디자인 패턴(SOLID 원칙 포함) / 상속 / STL 기반으로 결합도는 낮추고, 확장은 데이터 중심으로 가능한 구조로 설계 목표로 구현

### 🔹 책임 분리 (SOLID / SRP)

- **아이템 시스템**
  - **Loader**
    - dat 파일 파싱 및 데이터 해석만 담당
    - 아이템/효과/드랍 규칙 등 데이터 해석 전용
  - **Factory**
    - Loader 결과를 기반으로 Item 객체 생성
    - 아이템 생성의 유일한 통로
  - **EffectSystem**
    - 효과 규칙 정의 및 1회 적용/해제 로직 담당
    - (스탯 증감, 즉시 회복 등 “규칙” 중심)
  - EffectManager
    - 캐릭터에 적용 중인 효과 상태 관리
    - 지속시간 감소(tick), 만료 처리 시 EffectSystem 호출
      👉 아이템 데이터·생성·적용·상태를 역할별로 분리
- **인벤토리 시스템**
  - **Inventory**
    - 아이템 보관/소유권 관리
    - 장착/해제 + 사용 요청 처리(소비/버프/장비)
    - 아이템 사용의 시작 지점 역할
  - **useItem(...)**
    - “아이템 사용”은 Inventory가 시작점
    - 실제 효과 적용은 EffectSystem/Manager에 위임
  - **equip/unequip(...)**
    - 장착 슬롯(Weapon/Armor) 기준으로 장비 상태를 관리
    - Character 스탯 반영은 Character API를 통해 수행
      👉 Inventory는 아이템을 소유·선택하고, 적용은 외부에 위임
- **드랍 시스템**
  - **RewardRepository**
    - 몬스터 이름 → 드랍 규칙 저장소 (GUARANTEE=확정 드랍 / PICK=확률 드랍)
    - 드랍 규칙의 단일 조회 지점
  - **DropTable**
    - 아이템 프로토타입 보관
    - 아이템 clone 책임을 전담
  - **RewardManager /BattleRewardService**:
    - 전투 결과와 드랍 규칙을 종합하여 보상 산출
    - 골드/아이템을 Inventory에 반영
      👉 드랍 규칙과 아이템 원본을 조합해 전투 보상을 확정·적용
- **엔티티(도메인) 시스템**
  - **Entity**
    - 캐릭터/몬스터 공통 상태와 전투 기본 규칙
  - **Character**
    - 성장 및 자원 관리(레벨, 경험치, 골드)
    - 장비 및 효과에 의한 스탯 변화 수용
    - 행동 기반 API만 제공(heal, addAttack 등)
  - **Monster**:
    - 몬스터 고유 정보 보유
    - 사망 시점(onDeath)에서 사망 이벤트를 알리는 역할만 수행
      (보상/드랍 직접 처리 ❌)
      👉 공통 상태와 규칙은 Entity에, 개별 로직은 Character·Monster에 분리
- **게임·전투·UI 시스템**
  - **GameManager**
    - GameState / Phase / Round 관리
    - 각 서비스(Battle, Reward, UI) 조율
  - **BattleService**:
    - 전투 규칙 및 턴 진행
    - 수동/자동 전투 분기 처리
    - 전투 턴에 연동된 아이템 효과를 처리(인벤토리 연동)하고 전투 로그를 생성
  - **UIManager / UIGrid**
    - 출력·입력·그리드 렌더링 전담
    - 게임 로직과 완전히 분리
  - **BattleResult**:
    - 전투 결과를 담는 순수 데이터 객체
    - 승패, 획득 골드, 드랍 아이템, 턴 수, 로그 등 포함
      👉 GameManager가 흐름을 조율, BattleService가 전투를 진행, UI는 출력만 담당

---

### 🔹 Data-driven 설계

- **아이템 정의**: 가격, 효과, 지속시간, ASCII를 dat 파일로 외부화
- **드랍 규칙**: 몬스터 이름 → Rule(GUARANTEE / PICK) 구조로 관리
- **게임 흐름**: GameState / PhaseType로 진행을 명시적 상태로 모델링

👉 “게임 규칙은 코드로, 콘텐츠는 데이터로 확장”

---

### 🔹 디자인 패턴 적용

- **Factory Pattern**
  - ItemFactory에서 아이템 생성 규칙 중앙 관리
    (아이템 생성의 유일한 통로)
- **Repository Pattern**
  - RewardRepository를 드랍 규칙 단일 조회 지점으로 사용
    (드랍 규칙은 한 곳에만 정리)
- **Prototype Pattern**
  - DropTable에서 Item prototype을 clone하여 실사용 객체 생성
    (드랍/상점 구매 때마다 아이템을 신규 생성 방지)
- **Template + Callback**

  - loadImpl + consumeItem으로 파싱 로직 재사용

          (dat 파일 파싱 코드 중복 문제 해결)

- **State 개념**

  - GameState 기반 게임 진행 흐름 제어

         (메인 메뉴 / 전투 / 상점 / 인벤토리 등을 상태로 구분)

- **Service Layer**

  - BattleService(전투) / BattleRewardService(드랍)로 도메인 로직 분리

        (캐릭터, 몬스터 로직 과도하게 몰리는 문제 해결)

- **DTO / Result Object**:
  - BattleResult로 전투 결과를 계층 간 전달
    (UI, 보상, 로그 처리에서 공통 사용)
- **Callback**
  - 전투 중 인벤토리 오픈을 외부(GameManager)에 위임
    (전투 도중 “인벤토리 열기” 같은 요청 GameManager에서 처리)

---

### 🔹 다형성 · 상속 구조

- **Entity 기반 상속**: Character / Monster가 공통 전투 인터페이스 공유
- **Item 기반 상속**: Heal / Buff / Equip 아이템 공통 처리
- _Inventory는 Item 기준으로 동작_: 구체 타입을 몰라도 보관/장착/사용 흐름 유지
- **데이터 기반 다형성**: EffectType / Rule 분기로 실제 동작 결정

👉 캐릭터·몬스터·아이템을 공통 규칙으로 다루고, 실제 동작은 데이터로 결정

---

### 🔹 STL 기반 관리

- `vector<Item*> items`
  → **인벤토리 아이템을 순서대로 관리하기 위해 사용**
- `vector<Item*> equipped`
  → **고정된 장착 슬롯을 인덱스로 빠르게 접근하기 위해 사용**
- `vector<Effect>`
  → **여러 효과를 턴 순서대로 처리하기 위해 사용**
- `unordered_map<string, Rule>`
  → **몬스터별 드랍 규칙을 빠르게 조회하기 위해 사용**
- `vector<string>`
  → **전투 로그와 드랍 결과를 발생 순서대로 기록하기 위해 사용**
- `vector<MonsterData>` / `map<string, int>`
  → **몬스터 풀 순회와 처치 수 집계를 위해 사용**
- `function<>`
  → **전투 로직과 UI를 분리하기 위해 콜백으로 사용**

### 사용자 경험(UX) 구현

### **🎮 게임 핵심 흐름 (Core Gameplay Loop)**

![게임핵심흐름](https://raw.githubusercontent.com/JongKyuHong/image/main/게임핵심흐름.png)

### 사용자 경험(UX) 구현

### **🎮 게임 핵심 흐름 (Core Gameplay Loop)**

플로우 차트 이미지

### 🔧 설계 의도 및 확장 포인트

- 기본 가이드에서는 **자동 행동 결정 방식**을 제시했으나,
  플레이 스타일의 다양성을 위해 **자동 / 수동 전투 선택 옵션**으로 확장
- 자동 전투 시에도 장착 아이템과 인벤토리 효과가 반영되며,
  수동 전투에서는 공격 및 아이템 사용을 직접 선택 가능

### 🎮 UX 관점의 전투 설계

- 게임 시작: 전투 방식 선택으로 플레이 흐름 결정
- 게임 진행 중: 선택한 방식에 맞는 일관된 전투 경험 유지
- 게임 종료: 동일한 조작 흐름 속에서 성장과 결과를 체감

### 기능 테스트

![테스트](https://raw.githubusercontent.com/JongKyuHong/image/main/테스트.png)

### 시연 영상(일반 몬스터 부분)

[시연영상](https://www.youtube.com/watch?v=cdFyyandFA8)

### 시연 파트

게임 플레이 보스 파트 부분 직접 시연
